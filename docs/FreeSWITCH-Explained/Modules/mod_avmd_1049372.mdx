# mod_avmd

![](/attachments/1049372/10683543.png)

## 关于

Advanced Voice Mail Detection 模块旨在检测音频信号中的单频恒幅音调。通常用于检测语音信箱或答录机问候语的末尾的“滴声”（类似于上述的这个 [beep](/attachments/1049372/10682567.mp3) \[[原始](/attachments/1049372/10682568.raw)\] 中的 1000 Hz 滴声，还请参阅下面的“拨号计划示例”）。这在您希望在收件人的消息系统上留下录音消息，但又不想等待常用的 [wait\_for\_silence](https://wiki.freeswitch.org/wiki/Misc.%5FDialplan%5FTools%5Fwait%5Ffor%5Fsilence "Misc. Dialplan Tools wait for silence") 的暂停完成时非常有用，并且您正在寻找滴声以开始录音时。Avmd 还可（应该）与拨号器进行出站呼叫同时使用，与答录机检测模块（AMD）同时使用，因为检测到语音邮件很大程度上表明该呼叫是由机器接听的，而 AMD 无法检测声音（尽管在 AMD 的情况下，您通常希望尽快检测到机器，比在语音邮件问候语的末尾更快）。 

点击展开目录

* 1 [工作原理及其消耗](#how-it-works-and-how-hungry-it-is)  
   * 1.1 [详细信息](#details)  
   * 1.2 [CPU使用（所需CPU量）](#cpu-usage-how-much-cpu-it-needs)
* 2 [用法](#usage)  
   * 2.1 [API接口](#api-interface)  
   * 2.2 [启动](#start)  
   * 2.3 [停止](#stop)  
   * 2.4 [展示](#show)  
   * 2.5 [重新加载](#reload)  
   * 2.6 [设置](#set)  
   * 2.7 [加载](#load)  
   * 2.8 [APP接口](#app-interface)  
      * 2.8.1 [命令](#commands)  
         * 2.8.2 [拨号计划示例](#dialplan-examples)
* 3 [AVMD会话的动态配置](#dynamic-configuration-of-avmd-session)  
   * 3.1 [参数解释](#parameters-explained)
* 4 [事件](#events)  
   * 4.1 [事件类型](#event-types)  
   * 4.2 [事件示例](#event-examples)
* 5 [通道变量](#channel-variables)  
   * 5.1 [avmd_detect](#avmd_detect)
* 6 [脚本](#scripts)  
   * 6.1 [在通话中启动AVMD并获取事件](#start-avmd-on-the-call-and-get-events)  
   * 6.2 [在通话中启动AVMD并检查检测结果](#start-avmd-on-the-call-and-check-detection-result)  
   * 6.3 [对FreeSWITCH进行多次呼叫（用于测试运行AVMD的呼叫的CPU使用情况）](#make-multiple-calls-to-freeswitch-useful-for-testing-cpu-usage-on-calls-running-avmd)
* 7 [配置](#configuration)
* 8 [反馈/问题](#feedbackquestions)

## 工作原理及其消耗

AVMD使用DESA-2算法从音频信号的TKEO能量算子中分离瞬时频率和振幅的估计。DESA-2使用三个样本导数估计。该算法速度快，计算简单，但在存在噪声的情况下稍微不准确，尽管对于几乎所有实际用途来说足够好。

AVMD 提供三种检测模式，可以用于检测三种类型的声音：

* 恒定幅度的检测
* 恒定频率的检测（可用于检测DTMF音频）
* 频幅恒定的检测（默认）

调用 AVMD 的 start 方法会启动处理带有不同分辨率和/或偏移的音频帧的检测线程。在 AVMD 会话成功启动后，会触发 avmd::start 事件。然后，FreeSWITCH 核心会对每个传入音频帧调用 AVMD，并且所有检测线程会根据其分辨率、偏移和延迟来处理传入的音频帧。一旦信号被确定为符合指定的标准（恒定幅度、频率或两者兼备），将触发 avmd::beep 事件。应用程序应停止调用 AVMD，这会触发 avmd::stop 事件。

已知还有其他能量分离算法，包括但不限于DESA-1、方差-协方差方法、PRONY等。这些算法在估计差异信号能量或其他调整方面存在差异。一些研究者报道称，这些算法在鲁棒性和准确性方面的结果更好，至少在某些条件下，但它们需要更多的计算资源。因此，将来可能会对 avmd 进行扩展以实现其中一些算法。目前，avmd 使用 DESA-2，这在生产环境中导致单个数字的百分之几的误差。

### 详细信息

这个 UML 图表描述了在 AVMD 会话中每个检测线程对音频帧的处理，当 AVMD 主线程在avmd_process函数中发出开始处理的信号后。![](/download/temp/plantuml13869310088330138598.png)

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

版本 1.6.11 中新增功能：

* 多线程检测器和滞后检测器
* 三种检测模式（仅幅度、仅频率、同时）
* 在配置 XML 中添加了检测模式设置
* 在配置 XML 中添加了检测线程数和滞后检测器数设置
* 扩展事件 API（在事件中增加有关检测会话和结果的更多信息）

![](https://wiki.freeswitch.org/images/thumb/4/49/Error.png/64px-Error.png)

与呼叫简单回放音乐相比，运行 avmd（默认配置下有 36 个检测器）会消耗大约 10 倍的CPU资源。同时，检测质量（随着检测线程数增加而增加）与 CPU 使用率之间存在权衡。请根据您的需求和计算资源调整 AVMD 配置 XML 中的检测器数量或每个会话的数量。

### CPU 使用率（所需 CPU 百分比）

在 8 核 Intel i7-4790K CPU 上进行的测试表明，与呼叫简单回放音乐相比，运行 avmd（默认配置下有 36 个检测器）会使您的 CPU 忙碌程度增加约 10 倍。下表显示了当多个呼叫转接到分机时，FreeSWITCH 使用的总CPU资源的百分比，其中一个呼叫仅回放音乐，另一个呼叫除此之外还运行 avmd。

结果通过 top 命令的输出（top -p \`pidof freeswitch\`）获得。

| extension/# of calls | 10   | 50    | 100  | 150   | 200              |
| -------------------- | ---- | ----- | ---- | ----- | ---------------- |
| 播放音乐              | 1.25 | 3.25  | 6.25 | 7.9   | 9.75             |
| 播放音乐 + avmd       | 12.9 | 32.13 | 47.8 | 63.75 | 95（GUI卡顿）    |

## 使用方法

使用起来非常简单。

* 在特定的语音通道上“启动”检测。
* avmd::beep指示检测到哔声已被传送到ESL套接字监听器、命令提示符并写入日志。Avmd还设置了通道变量（参见“通道变量”）。
*（可选）在特定的语音通道上“停止”检测。

因此，您将在控制台上看到类似于以下的输出：

**控制台日志（在给定的示例answering_machine_sound_effect_8000.raw上运行avmd）**

```perl
2016-10-13 15:37:06.765346 [INFO] mod_avmd.c:1113 Avmd dynamic configuration: debug [0], report_status [1], fast_math [0], require_continuous_streak [1], sample_n_continuous_streak [3], sample_n_to_skip [0], require_continuous_streak_amp [1], sample_n_continuous_streak_amp [3], simplified_estimation [1], inbound_channel [1], outbound_channel [0], detection_mode [2], detectors_n [36], detectors_lagged_n [1]
2016-10-13 15:37:06.765346 [INFO] mod_avmd.c:610 Avmd session initialized, [8000] samples/s
2016-10-13 15:37:06.765346 [INFO] mod_avmd.c:1411 Avmd on channel [loopback/1706-b] started!
2016-10-13 15:37:13.885357 [INFO] mod_avmd.c:1901 <<< AVMD - Beep Detected [2][1][0][36]: f = [999.589033] variance = [0.000003], amplitude = [11976.009917](max [15783.276141]) variance = [871.936721], detection time [7099987] [us] >>>
2016-10-13 15:37:15.265359 [INFO] mod_avmd.c:1467 Avmd on channel [loopback/1706-b] stopped, beep status: [DETECTED], total running time [8500013] [us]
```

### API接口

此接口用于从mod_event_socket进行调用。

### 开始

在给定的通道上启动avmd检测。

用法：`<uuid> start`

`<uuid>` - 通道唯一标识符

示例：

afcbe4db-cdb3-4e1c-98c5-c12fea8474cc start

![](https://wiki.freeswitch.org/images/thumb/c/cb/Warning.png/64px-Warning.png)

在所有文档中，我们省略了"api avmd"（在从ESL、telnet客户端发起的调用中使用），以及"avmd"（在从fs_cli、dialplan发起的调用中使用）。然而，我们假定这个前缀总是存在的。在所有这些文档中，我们用&lt;x>表示对于给定命令所需的参数，在发出命令时&lt;x>将变成x。例如，上面的uuid是通道的唯一标识符，&lt;uuid>应该理解为"在此处插入通道的uuid"（必填参数），当发出start/stop命令时。扩展这个例子，假设从ESL执行了以下命令来产生在"示例事件"中显示的结果：

api avmd afcbe4db-cdb3-4e1c-98c5-c12fea8474cc start

或者从fs_cli使用这种形式：

avmd afcbe4db-cdb3-4e1c-98c5-c12fea8474cc start

### stop

停止给定通道上的avmd检测。

使用方法: &lt;uuid> stop

&lt;uuid> - 通道的唯一标识符

示例:

afcbe4db-cdb3-4e1c-98c5-c12fea8474cc stop

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

自1.6.8版本以来，以下所有命令都可用。

### show

打印到控制台当前的默认/全局avmd设置。

使用方法: show

示例:

show

### reload

重新加载avmd的XML配置设置，以使其与FS中的设置一致。

使用方法: reload

示例:

reload

设置是从FS存储加载的。这意味着新数据将是从启动时或上次调用reloadxml命令时从$CONFDIR加载到FS的副本。如果您更改了XML文件并希望avmd加载它，只需调用FS命令reloadxml即可。但是，您也可以使avmd加载FS在上次调用reloadxml时缓存的XML设置文件。avmd的重新加载方法将执行此操作，它总是将设置恢复为FS存储在其RAM中的内容，而FS在RAM中的内容是与最近的reloadxml命令对应的XML文件的版本。

### set

设置内部/外部通道的检测。

  
用法：set inbound | outbound | default

inbound - 在内部通道上设置检测

outbound - 在外部通道上设置检测

default - 将avmd设置为默认工厂设置（参见"avmd会话的动态配置"）

  
示例：

set inbound

set outbound

set default

### load

从RAM加载avmd的XML设置，并设置内部/外部通道的检测。

  
用法：load inbound | outbound

inbound - 在内部通道上设置检测

outbound - 在外部通道上设置检测

  
示例：

load inbound

load outbound

  
此命令相当于reload + set。load inbound == reload + set inbound，load outbound == reload + set outbound。

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

有时您可能希望在应答后几秒钟启动avmd。在这种情况下，在收到应答事件后，发出以下命令：

api sched_api +3 none avmd &lt;uuid> start

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

为了获得准确的检测结果并节省系统资源（CPU和内存），您应执行以下操作：

* 在接听电话之后再开始 AVMD。在许多情况下，最好在接听电话后等待几秒钟再开始 AVMD。在接听电话之前启动 AVMD 会导致 CPU 资源的浪费。
* 一旦收到 AVMD 事件，即使不会返回更多的事件，您也应该显式停止 AVMD。

### 应用程序接口

#### 命令

此接口允许来自拨号计划和脚本(LUA、JavaScript)的调用。从 1.6.8 版本开始，应使用以下版本的应用程序：

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

从 1.6.9 版本开始提供。

| APP (命令名称)   | 是否有动态参数？ | 使用方法（来自呼叫计划）                                                                                                                                                                                                                | 描述                                                                                      | 备注                                  |
| --------------- | -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- | ------------------------------------ |
| avmd\_start     | 否             | &lt;action application="avmd\_start"/>                                                                                                                                                                                              | 以默认参数开始 AVMD 会话                                                                            |                                      |
| avmd\_start     | 是             | &lt;action application="avmd\_start" data=""/>                                                                                                                                                                                      | 以默认参数开始 AVMD 会话                                                                            | data="" 是合法的，尽管没有意义              |
| avmd\_start     | 是             | &lt;action application="avmd\_start" data= "动态参数：以逗号分隔的键=值选项列表"/>（例如：&lt;action application\="avmd\_start" data\="inbound\_channel=0,outbound\_channel=1, sample\_n\_continuous\_streak=19,sample\_n\_to\_skip=18,debug=0,detectors\_n=3,detectors\_lagged\_n=1,report\_status=1"/>) | 以设置的参数开始 AVMD 会话，未在此指定的参数的值将使用配置文件中的默认值                              |                                      |
| avmd\_stop      | 否             | &lt;action application="avmd\_stop"/>                                                                                                                                                                                               | 停止 AVMD 会话                                                                                   |                                      |

使用动态参数传递时，avmd模块将验证以逗号分隔的键值对的正确性（可以为空，即data=""），并在验证成功时将找到的键设置为指定的值。如果验证不成功，avmd会将会话参数设置为当前存储的默认值（这意味着它是在上一次调用avmd set/ avmd load时设置的，或者如果没有这样的调用-则从XML配置或默认的工厂设置中获取，如果配置加载失败\[没有配置或配置无效\]）。

下面的APP调用将在1.6.8版本后被弃用，但在下一个发布版本之前仍然可用，以保持向后兼容性。当您调用这些方法之一时，警告"YOU ARE USING DEPRECATED APP INTERFACE"将打印到日志中。

| APP（命令名）| 描述| 用法（从呼叫计划）| 动态参数？| 备注|
| ------------------ | ---------------------------------------------------- | --------------------------------------------------------------------------------- | ------------------- | --------------------------------------------------------------------------------------------------------- |
| avmd               | 启动/停止与数据参数相关的avmd会话| &lt;action application="avmd" data="start"/>&lt;action application="avmd" data="stop"/> | 否                 | ![](https://wiki.freeswitch.org/images/thumb/4/49/Error.png/64px-Error.png)1.6.8版本后不推荐使用 |

#### 呼叫计划示例

**拨号计划示例1（在给定示例 answering\_machine\_sound\_effect\_8000.raw 上运行 avmd）** 
```xml
<extension name="1706">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd_start"/>
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd_stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

![](https://wiki.freeswitch.org/images/thumb/b/b3/Info.png/64px-Info.png)

自1.6.9版本开始可用。

**拨号计划示例2（在给定示例 answering\_machine\_sound\_effect\_8000.raw 上运行 avmd）** 
```xml
<extension name="1706">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd_start" data="simplified_estimation=0,inbound_channel=1,outbound_channel=1,sample_n_continuous_streak=25,sample_n_to_skip=18,debug=0,report_status=0"/> <!-- 这个配置设置了更多的样本在每个音频帧的开始时被跳过，并且需要超过默认数量的连续好的估计值才能验证检测 -->
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd_stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

**拨号计划示例3（在给定示例 answering\_machine\_sound\_effect\_8000.raw 上运行 avmd）**

```xml
<extension name="1706_playback">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd_start" data="debug=1,sample_n_to_skip=19,inbound_channel=1,outbound_channel=0"/>    <!-- 入站配置，如果您从脚本开始呼叫并从FS播放音频，则可以使用此配置 -->
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd_stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

**拨号计划示例4（在给定的 answering\_machine\_sound\_effect\_8000.raw 上运行 avmd，仅处于振幅模式）** 展开源代码

```xml
<extension name="1706_amplitude_only">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd_start" data="detection_mode=0"/>    <!-- 将 AVMD 设置为检测振幅恒定的声音（忽略频率） -->
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd_stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

**拨号计划示例5（在给定的 answering\_machine\_sound\_effect\_8000.raw 上运行 avmd，仅处于频率模式）** 展开源代码

```xml
<extension name="1706_frequency_only">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd_start" data="detection_mode=1"/>    <!-- 将 AVMD 设置为检测频率恒定的声音（忽略振幅） -->
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd_stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

![](https://wiki.freeswitch.org/images/thumb/4/49/Error.png/64px-Error.png)

自1.6.8版本起已被弃用

**拨号计划示例6（对给定示例answering\_machine\_sound\_effect\_8000.raw运行avmd）** 扩展源

```xml
<extension name="1706">
    <condition field="destination_number" expression="^1706$">
        <action application="avmd" data="start"/>
        <action application="playback" data="voicemail/8000/answering_machine_sound_effect_8000.raw"/>
        <action application="avmd" data="stop"/>
        <action application="hangup"/>
    </condition>
</extension>
```

## 动态配置avmd会话

当avmd会话启动时，其参数是根据当前存储在FreeSWITCH的RAM中的值进行配置的。这些值取自avmd XML配置文件avmd\_conf.xml，并可以通过配置命令（set/load/reload）进行更改。还可以通过从拨号计划中传递逗号分隔的参数和它们的值来单独设置avmd会话的每个参数，即使在1.6.9版本中也是如此（从APP接口无法使用，如事件套接字）。

### 参数解释

下表解释了可以动态设置的参数的含义。

| 参数                               | 作用域       | 描述                                                                                                                                                                                                                                                                                                             | 数据类型    | 默认值       | 备注                                                                                                                                                                                                                                                                                                                                                   |
|------------------------------------|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| debug                              | 全局         | 启用/禁用将 avmd 中间计算记录到日志中                                                                                                                                                                                                                                                                              | uint8\_t  | 0             |                                                                                                                                                                                                                                                                                          |
| report\_status                     | 全局         | 启用/禁用详细日志记录（和控制台报告）检测状态和其他诊断，如 avmdsession 启动时使用的参数，配置参数的更改，会话结束后哔哔检测状态（停止事件独立于此设置触发，并在其中包括蜂鸣器状态）                                                                                                                  | uint8\_t  | 1             |                                                                                                                                                                                                                                                                                          |
| fast\_math                         | 全局         | 启用/禁用更快计算余弦值 - 创建表时将浮点数映射到整数并返回给定这些整数索引的余弦值                                                                                                                                                | uint8\_t  | 0             | 在 Windows 上不可用（该设置将被忽略）                                                                                                                                                                                                                                                   |
| require\_continuous\_streak        | 每个会话     | 在频率估计中使用：启用/禁用对 SMA 缓冲区进行连续检查所需的连续元素数（由 sample\_n\_continuous\_streak 给出），无需重置即可将蜂鸣检测分类为有效                                                                                                                                                      | uint16\_t | 1             |                                                                                                                                                                                                                                                                                          |
| sample\_n\_continuous\_streak      | 每个会话     | 在频率估计中使用：指定 SMA 缓冲区中的连续元素数，无需重置即可将蜂鸣检测分类为有效                                                                                                                                                                                                                          | uint16\_t | 3             | 此参数有助于避免误报哔声，值越大，误检几率越小，但也会减小检测到真正蜂鸣 声的机会                                                                                                                                                                           |
| require\_continuous\_streak\_amp   | 每个会话     | 在幅度估计中使用：启用/禁用对 SMA 缓冲区进行连续检查所需的连续元素数（由 sample\_n\_continuous\_streak 给出），无需重置即可将蜂鸣检测分类为有效                                                                                                                                                      | uint16\_t | 1             |                                                                                                                                                                                                                                                                                          |
| sample\_n\_continuous\_streak\_amp | 每个会话     | 在幅度估计中使用：指定 SMA 缓冲区中的连续元素数，无需重置即可将蜂鸣检测分类为有效                                                                                                                                                                                                                          | uint16\_t | 3             | 此参数有助于避免误报哔声，值越大，误检几率越小，但也会减小检测到真正蜂鸣声的机会                                                                                                                                                                           |
| sample\_n\_to\_skip                | 每个会话     | 指定从帧的开头开始跳过的样本数和/或发生重置后要跳过的样本数                                                                                                                                                                                                                                                         | uint8\_t  | 0             | 该参数用于跳过每帧的前几次估计（因为这些估计可能不准确）。增加此参数的值（最多约60）可以帮助在某些情况下提供更稳健的检测                                                                                                                                                                    |
| simplified\_estimation             | 每个会话     | 启用/禁用基于以0到PI/2为x的sin(x)的简化频率估计                                                                                                                                                                                                                                                                   | uint8\_t  | 1             | 自1.6.10版本开始，在此版本之前，将忽略此参数。只有在使用 DESA 原始算法的情况下，才会使用此参数，其中每个估计都需要计算一个 cos 的反余弦，但从1.6.10版本开始，我们使用调整后的 DESA 算法来避免计算余弦值。                                                                                                                                          |
| inbound\_channel                   | 每个会话     | 启用/禁用内部信道上的 avmd                                                                                                                                                                                                                                                                                      | uint8\_t  | 0             |                                                                                                                                                                                                                                                                                          |
| outbound\_channel                  | 每个会话     | 启用/禁用外部信道上的 avmd                                                                                                                                                                                                                                                                                      | uint8\_t  | 1             |                                                                                                                                                                                                                                                                                          |
| detection\_mode                    | 每个会话     | 设置 AVMD 将检测的声音特征，即恒定幅度声音或恒定频率声音或同时具有恒定幅度和频率的声音（0 = AVMD\_DETECT\_AMP，1 = AVMD\_DETECT\_FREQ，2 = AVMD\_DETECT\_BOTH）                                                                                              | uint8\_t  | 2             | 默认值为2，表示 AVMD\_DETECT\_BOTH                                                                                                                                                                                                                                                     |
| detectors\_n                       | 每个会话     | 设置在不同分辨率和/或偏移量下运行的检测线程数                                                                                                                                                                                                                                                                      | uint8\_t  | 36            | 增加这些数字可以提供更好的检测质量，但可能会使 CPU 占用率很高，可能需要在较慢的机器上减小detectors\_n 值。 默认设置能够在带有8个核心的16GB机器上处理高峰值约300个会话，CPU 为 Intel(R) Core(TM) i7-4790K @ 4.00GHz                                                                      |
| detectors\_lagged\_n               | 每个会话     | 设置处理音频时在语音流开始时跳过几帧的检测线程数                                                                                                                                                                                                                                                                | uint8\_t  | 1             |                                                                                                                                                                                                                                                                                          |

## 事件

### 事件类型

以下是 avmd 事件的类型：

| 事件名称                     | 描述                              | 自定义字段                                                                                                                                         | 使用方式（如何订阅）                | 备注                                                  |
| --------------------------- | -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------- | ----------------------------------------------------- |
| AVMD\_EVENT\_BEEP           | 检测到恒定频率信号               | Unique-IDCall-commandBeep-StatusFrequencyFrequency-varianceAmplitudeAmplitude-varianceDetection-timeDetector-resolutionDetector-offsetDetector-index | 事件 plain CUSTOM avmd::beep       | 仅在检测到蜂鸣声时触发                                 |
| AVMD\_EVENT\_SESSION\_START | avmd 会话已启动                  | Unique-IDCall-commandStart-time                                                                                                                      | 事件 plain CUSTOM avmd::start      |                                                       |
| AVMD\_EVENT\_SESSION\_STOP  | avmd 会话已停止                  | Unique-IDCall-commandBeep statusTotal-time                                                                                                           | 事件 plain CUSTOM avmd::stop       |                                                       |

要获取所有 avmd 事件，您可以订阅所有 FS 事件，并按自定义 avmd 字段进行过滤，即"Call-command" 拨号命令。

```cpp
事件 all
筛选器 Call-command avmd
```

### 事件示例

从上面的拨号计划示例中运行的例子avmd会话开始事件

**从上面的拨号计划示例中运行的例子avmd会话开始事件** 展开源码

```xml
事件子类: avmd%3A%3Astart
事件名称: CUSTOM
核心UUID: 9c7e6daf-cdc6-4f1d-931e-fcb886cffde9
FreeSWITCH主机名: westernst
FreeSWITCH开关名称: westernst
FreeSWITCH-IPv4: 192.168.1.60
FreeSWITCH-IPv6: %3A%3A1
本地事件日期: 2016-10-13%2015%3A37%3A06
GMT事件日期: Thu,%2013%20Oct%202016%2014%3A37%3A06%20GMT
事件时间戳: 1476369426765346
事件调用文件: mod_avmd.c
事件调用函数: avmd_fire_event
事件调用行号: 678
事件序列: 5967
唯一标识符: ffbeebb0-8480-4422-9337-bd666d15358d
Call-command: avmd
开始时间: 1476369426765346
```

从上面的拨号计划示例中运行的例子beep事件

**从上面的拨号计划示例中运行的例子avmd beep事件** 展开源码

```xml
事件子类: avmd%3A%3Abeep
事件名称: CUSTOM
核心UUID: 9c7e6daf-cdc6-4f1d-931e-fcb886cffde9
FreeSWITCH主机名: westernst
FreeSWITCH开关名称: westernst
FreeSWITCH-IPv4: 192.168.1.60
FreeSWITCH-IPv6: %3A%3A1
本地事件日期: 2016-10-13%2015%3A37%3A13
GMT事件日期: Thu,%2013%20Oct%202016%2014%3A37%3A13%20GMT
事件时间戳: 1476369433885357
事件调用文件: mod_avmd.c
事件调用函数: avmd_fire_event
事件调用行号: 678
事件序列: 5971
唯一标识符: ffbeebb0-8480-4422-9337-bd666d15358d
Call-command: avmd
Beep-状态: DETECTED
频率: 999.589033
频率方差: 0.000003
振幅: 11976.009917
振幅方差: 871.936721
检测时间: 7099987
探测器分辨率: 1
探测器偏移量: 0
探测器索引: 36
```

示例 avmd 会话停止（从上面的拨号计划示例中运行的）

**示例 avmd 会话停止（从上面的拨号计划示例中运行的）** 扩展源代码

```xml
Event-Subclass: avmd%3A%3Astop
Event-Name: CUSTOM
Core-UUID: 9c7e6daf-cdc6-4f1d-931e-fcb886cffde9
FreeSWITCH-Hostname: westernst
FreeSWITCH-Switchname: westernst
FreeSWITCH-IPv4: 192.168.1.60
FreeSWITCH-IPv6: %3A%3A1
Event-Date-Local: 2016-10-13%2015%3A37%3A15
Event-Date-GMT: Thu,%2013%20Oct%202016%2014%3A37%3A15%20GMT
Event-Date-Timestamp: 1476369435265359
Event-Calling-File: mod_avmd.c
Event-Calling-Function: avmd_fire_event
Event-Calling-Line-Number: 678
Event-Sequence: 5975
Unique-ID: ffbeebb0-8480-4422-9337-bd666d15358d
Call-command: avmd
Beep-Status: DETECTED
Total-time: 8500013
```


## 通道变量

### avmd_detect

当在给定通道上启动 avmd 会话时，其通道变量 "avmd_detect" 被设置为 FALSE。Avmd 会在触发 AVMD_EVENT_BEEP 前将此变量设置为 TRUE，因此可以通过检查给定通道上此变量的值来检查检测结果。但是，这不是获取检测指示的支持方式。您应该订阅并处理 avmd::beep 事件，或者检查 avmd::stop 事件中的 Beep-status 字段的值。请查看下面的 "在通话上启动 AVMD 并检查检测结果"，了解更多详细信息。

  
## 脚本

在 AVMD 源文件夹（src/mod/applications/mod_avmd/scripts）中可以找到一些有用的 Perl 脚本。

### 在通话上启动 AVMD 并获取事件

**mod_avmd 在发起的通话上启动 AVMD 会话**

```perl
#!/usr/bin/perl -w


#brief  订阅 avmd 事件并将其打印到控制台。
#author Piotr Gregor <piotr@dataandsignal.com>
#date   2016年9月13日 下午9:44
```

```perl
#!/usr/bin/perl -w
use strict;
use warnings;
require ESL;

my $host = "127.0.0.1";
my $port = "8021";
my $pass = "ClueCon";

my $format = "plain";

if ($#ARGV + 1 eq 1) {
    $format = $ARGV[0];
    print "Using format: [" .$format ."]\n";
}

my $con  = new ESL::ESLconnection($host, $port, $pass);
if (!$con) {
    die "无法连接到 $host:$port\n";
}
if ($con->connected()) {
    print "连接成功。\n";
} else {
    die "连接失败。\n";
}

print "订阅 avmd 事件...\n";
$con->events("plain", "CUSTOM avmd::start");
$con->events("plain", "CUSTOM avmd::stop");
$con->events("plain", "CUSTOM avmd::beep");

print "等待事件...\n";
while($con->connected()) {
    my $e = $con->recvEvent();
    my $avmd_event_type = ""; 
    $avmd_event_type = $e->getHeader("Event-Subclass");
    if ($avmd_event_type eq 'avmd::start') {
        print "\n--------------------\n\n";
    }   
    if ($e) {
        my $body = $e->serialize($format);
        print $body;
        print "\n\n";
    }   
}

print "已断开连接。\n\n";
```

### 在呼叫上启动 AVMD 并检查检测结果

**mod_avmd 在原始呼叫上启动 AVMD 会话并检查检测结果**

#简介
通过调用avmd测试套件中的语音信箱来测试avmd模块，并将检测结果打印到控制台。

#作者
Piotr Gregor <piotr@dataandsignal.com>

#详细信息
如果你正在测试拨号计划中的语音信箱功能，那么avmd必须被设置为入站模式，可以在全局环境中设置（通过在fs_cli中运行avmd set inbound命令），或者在拨号计划设置中（<action application="avmd_start" data="inbound_channel=1,outbound_channel=0"）进行设置，也可以动态地针对每个呼叫进行设置。

#日期
2016年9月15日 下午3:00

$|++;   # 打开自动刷新
use strict;
use warnings;
require ESL;
use POSIX;
use Time::HiRes;

# `<destination number : test result expectation>` 的哈希表
my %numbers = (
    503 => "未检测到",  # 双频（类似于变化幅度的单频），模式 [0] AVMD_DETECT_AMP
    504 => "未检测到",
    505 => "未检测到",
    506 => "未检测到",
    507 => "未检测到",
    508 => "未检测到",
    509 => "未检测到",
    510 => "未检测到",
    511 => "未检测到",
    512 => "未检测到",
    513 => "未检测到",
    514 => "未检测到",
    515 => "未检测到",
    516 => "未检测到",
    517 => "未检测到",
    518 => "未检测到",
    519 => "未检测到",
    520 => "未检测到",
    521 => "未检测到",
    522 => "未检测到",
    523 => "未检测到",
    603 => "已检测到",  # 双频（类似于变化幅度的单频），模式 [1] AVMD_DETECT_FREQ
    604 => "已检测到",
    605 => "已检测到",
    606 => "已检测到",
    607 => "已检测到",
    608 => "已检测到",
    609 => "已检测到",
    610 => "已检测到",
    611 => "已检测到",
    612 => "已检测到",
    613 => "已检测到",
    614 => "已检测到",
    615 => "已检测到",
    616 => "已检测到",
    617 => "已检测到",
    618 => "已检测到",
    619 => "已检测到",
    620 => "已检测到",
    621 => "已检测到",
    622 => "已检测到",
    623 => "已检测到",
    703 => "未检测到",  # 双频（类似于变化幅度的单频），模式 [2] AVMD_DETECT_BOTH
    704 => "未检测到",
    705 => "未检测到",
    706 => "未检测到",
    707 => "未检测到",
    708 => "未检测到",
    709 => "未检测到",
    710 => "未检测到",
    711 => "未检测到",
    712 => "未检测到",
    713 => "未检测到",
    714 => "未检测到",
    715 => "未检测到",
    716 => "未检测到",
    717 => "未检测到",
    718 => "未检测到",
    719 => "未检测到",
    720 => "未检测到",
    721 => "未检测到",
    722 => "未检测到",
    723 => "未检测到",
    840531000 => "已检测到",  # 模糊的声音留言，模式 AVMD_DETECT_BOTH
    840531001 => "已检测到",
    840531002 => "已检测到",
    840531003 => "已检测到",
    840531004 => "已检测到",
    840531005 => "已检测到",
    840531006 => "已检测到",
    840531007 => "已检测到",
    840531008 => "已检测到",
    840531009 => "已检测到",
    840531010 => "已检测到",
    840531011 => "已检测到",
    840531012 => "已检测到",
    840531013 => "已检测到",
    840531014 => "已检测到",
    840531200 => "已检测到",  # 模糊的声音留言，模式 AVMD_DETECT_FREQ
    840531201 => "已检测到",
    840531202 => "已检测到",
    840531203 => "已检测到",
    840531204 => "已检测到",
    840531205 => "已检测到",
    840531206 => "已检测到",
    840531207 => "已检测到",
    840531208 => "已检测到",
    840531209 => "已检测到",
    840531210 => "已检测到",
    840531211 => "已检测到",
    840531212 => "已检测到",
    840531213 => "已检测到",
    840531214 => "已检测到",
    840531400 => "已检测到",  # 模糊的声音留言 ATT套餐
    840531401 => "已检测到",
    840531402 => "已检测到",
    840531403 => "已检测到",
    840531404 => "已检测到",
    840531405 => "已检测到",
    840531051 => "未检测到",  # "Save tonight" by Eagle-Eye Cherry 被 D-Lete-Funk-K 演唱的片段
);
my $host = "127.0.0.1";
my $port = "8021";
my $pass = "ClueCon";
my $playback = 'local_stream://moh';
my $context = 'default';
my $endpoint;
my $dest;
my $expectation;
my $callerid;
my $passed = 0;
my $failed = 0;
my $hanguped = 0;

```perl
if ($#ARGV + 1 eq 1) {
    $callerid = $ARGV[0];
    print "\n拨号使用的号码为[" .$callerid ."]\n";
} elsif ($#ARGV + 1 > 1) {
    die "请指定单个呼叫者ID。\n";
} else {
    die "请指定呼叫者ID。\n";
}
```

```perl
print "连接中...\t";
my $con  = new ESL::ESLconnection($host, $port, $pass);
if (!$con) {
    die "无法建立到 $host:$port 的连接\n";
}
if ($con->connected()) {
    print "成功。\n";
} else {
    die "连接失败。\n";
}
print "订阅 avmd 事件中...\t";
$con->events("plain", "CUSTOM avmd::start");
$con->events("plain", "CUSTOM avmd::stop");
$con->events("plain", "CUSTOM avmd::beep");
$con->events("plain", "CHANNEL_CALLSTATE");
$con->events("plain", "CHANNEL_HANGUP");
print "成功。\n\n";
printf("\n运行 [%d] 个测试。\n\n", scalar keys(%numbers));
printf("发起 uuid | 目标号码 | 时间戳 | 期待结果 | 测试结果 | 频率 | 频率变化 | 幅度 | 幅度变化 | 分辨率 | 偏移量 | 索引\n\n");
foreach $dest (sort keys %numbers) {
    if (!$con->connected()) {
        last;
    }
    $expectation = $numbers{$dest};
    test_once($dest, $callerid, $expectation);
}
print "断开连接。\n\n";
if (($failed == 0) && ($hanguped == 0)) {
    printf("\n\n通过。全部通过 [%s]\n\n", $passed);
} else {
    printf("通过 [%s]，失败 [%s]，挂断 [%s]\n\n", $passed, $failed, $hanguped);
}
sub test_once {
    my ($dest, $callerid, $expectation) = @_;
    my $originate_string =
    '发起 ' .
    '{ignore_early_media=true,' .
    'origination_uuid=%s,' .
    'originate_timeout=60,' .
    'origination_caller_id_number=' . $callerid . ',' .
    'origination_caller_id_name=' . $callerid . '}';
    my $outcome = "";
    my $result = "";
    my $event_uuid = "N/A";
    my $uuid_in = "";
    my $freq = "N/A";
    my $freq_var = "N/A";
    my $amp = "N/A";
    my $amp_var = "N/A";
    my $resolution = "N/A";
    my $offset = "N/A";
    my $idx = "N/A";
    if(defined($endpoint)) {
        $originate_string .= $endpoint;
    } else {
        $originate_string .= 'loopback/' . $dest . '/' . $context;
    }
    $originate_string .=  ' ' . '&playback(' . $playback . ')';
    my $uuid_out = $con->api('create_uuid')->getBody();
    my ($time_epoch, $time_hires) = Time::HiRes::gettimeofday();
    printf("[%s] [%s]", $uuid_out, $dest);
    $con->bgapi(sprintf($originate_string, $uuid_out));
    while($con->connected()) {
        my $e = $con->recvEvent();
        if ($e) {
            my $event_name = $e->getHeader("Event-Name");
            if ($event_name eq 'CUSTOM') {
                my $avmd_event_type = $e->getHeader("Event-Subclass");
                if ($avmd_event_type eq 'avmd::start') {
                    $uuid_in = $e->getHeader("Unique-ID");
                } elsif (!($uuid_in eq "") && (($avmd_event_type eq 'avmd::beep') || ($avmd_event_type eq 'avmd::stop'))) {
                    $event_uuid = $e->getHeader("Unique-ID");
                    if ($event_uuid eq $uuid_in) {
                        if ($avmd_event_type eq 'avmd::beep') {
                            $freq = $e->getHeader("Frequency");
                            $freq_var = $e->getHeader("Frequency-variance");
                            $amp = $e->getHeader("Amplitude");
                            $amp_var = $e->getHeader("Amplitude-variance");
                            $resolution = $e->getHeader("Detector-resolution");
                            $offset = $e->getHeader("Detector-offset");
                            $idx = $e->getHeader("Detector-index");
                        }
                        $outcome = $e->getHeader("Beep-Status");
                        if ($outcome eq $expectation) {
                            $result = "通过";
                            $passed++;
                        } else {
                            $result = "失败";
                            $failed++;
                        }
                        last;
                    }
                }
            } elsif ($event_name eq 'CHANNEL_HANGUP') {
                $event_uuid = $e->getHeader("variable_origination_uuid");
                if ((defined $event_uuid) && ($event_uuid eq $uuid_out)) {
                    $outcome = "挂断";
                    $result = "挂断";
                    $hanguped++;
                    last;
                }
            }
        }
    }
    printf("\t[%s]\t[%s]\t\t[%s]\t[%s]HZ\t[%s]\t[%s]\t[%s]\t[%s][%s][%s]\n", POSIX::strftime('%Y-%m-%d %H:%M:%S', localtime($time_epoch)), $expectation, $result, $freq, $freq_var, $amp, $amp_var, $resolution, $offset, $idx);
    Time::HiRes::sleep(0.5);    # 防止 switch_core_session.c:2265 节流误差！33，switch_time.c:1227 超过会话速率30！
}
```

## 对 FreeSWITCH 进行多次呼叫（用于测试运行 AVMD 的通话的 CPU 负载）

**对 FreeSWITCH 进行多次呼叫** 展开源代码

```perl
#!/usr/bin/perl -w


#简介  进行多次呼叫。该脚本可用于检查运行 avmd 时的通话 CPU 使用情况（详见 test.txt）。
#作者 Piotr Gregor <piotr@dataandsignal.com>
#日期  2016年9月15日 下午2:44
#修改  2019年12月27日


use strict;
use warnings;
require ESL;
use POSIX;
use Time::HiRes;

my $host = "127.0.0.1";
my $port = "8021";
my $pass = "ClueCon";
my $extension_base = "sofia/internal/1000\@192.168.1.1";

my $playback = 'local_stream://moh';
my $context = 'default'; 
#示例：
#my $endpoint = "originate {originator_codec=PCMA,origination_uuid=%s}sofia/gateway/box_b/840534002  \&park()";
#my $endpoint = "originate {originator_codec=PCMA,origination_uuid=%s}sofia/gateway/%s/%s  \&park()";
my $endpoint;
my $gateway;
my $dest;
my $callerid;
my $thread_n;
my $idx = 0;


if ($#ARGV + 1 eq 3) {
    $dest = $ARGV[0];
    $callerid = $ARGV[1];
    $thread_n = $ARGV[2];
    print "正在同时拨打[" .$thread_n ."]个呼叫至[" .$dest ."]，呼叫者ID为[" .$callerid ."]\n";
} else {
    die "请指定目标号码、主叫号码和要进行的呼叫数量\n\n示例:\n./avmd_originate_multiple.pl 分机号 呼叫者 呼叫数量";
}

my $con  = new ESL::ESLconnection($host, $port, $pass);
if (!$con) {
    die "无法建立与 $host:$port 的连接\n";
}
if ($con->connected()) {
    print "连接成功。\n";
} else {
    die "连接失败。\n";
}

while($con->connected() && ($idx < $thread_n)) {
    call_once($dest, $callerid, $idx);
    $idx++;
    Time::HiRes::sleep(0.11);    # 避免 switch_core_session.c:2265 节流错误！33, switch_time.c:1227 超过每秒会话速率 30！
}

```perl
print "断开连接。\n\n";

sub call_once {
    my ($dest, $callerid, $idx) = @_;
    my $originate_string =
    'originate ' .
    '{ignore_early_media=true,' .
    'originator_codec=PCMA,' .
    'origination_uuid=%s,' .
    'originate_timeout=60,' .
    'origination_caller_id_number=' . $callerid . ',' .
    'origination_caller_id_name=' . $callerid . '}';

    if (defined($endpoint)) {
        $originate_string = '';
        $originate_string .= $endpoint;
    } else {
        $originate_string .= 'loopback/' . $dest . '/' . $context;
        $originate_string .= ' ' . '&playback(' . $playback . ')';
    }

    my $uuid = $con->api('create_uuid')->getBody();
    my ($time_epoch, $time_hires) = Time::HiRes::gettimeofday();
    printf("[%s]\t使用uuid [%s] [%s]发起呼叫... [%s]\n", $idx + 1, $uuid, POSIX::strftime('%Y-%m-%d %H:%M:%S', localtime($time_epoch)), $originate_string);

    $con->bgapi(sprintf($originate_string, $uuid));
    $con->api('uuid_setvar ' . $uuid . ' execute_on_answer avmd_start');
}
```

## 配置

在 'modules.conf' 中添加 avmd 模块：

applications/mod_avmd

重新构建并安装：

```xml
sudo make sure
sudo make install
```

要在启动时使 FreeSWITCH 加载它，只需将以下内容添加到 '$FS\_ROOT/conf/autoload\_configs/modules.conf.xml' 中：

```xml
<load module="mod_avmd"/>
```

## 反馈/问题

![](https://wiki.freeswitch.org/images/thumb/c/cb/Warning.png/64px-Warning.png)
```

如果有任何未被avmd检测到的语音邮件，请通过发送电子邮件至FreeSWITCH™用户邮件列表告知我们，我们会予以处理（请在主题前加上'mod\_avmd'并将电子邮件发送至[freeswitch-users@lists.freeswitch.org](mailto:freeswitch-users@lists.freeswitch.org)）。不过，请不要在用户列表上报告错误 - 请使用[jira.freeswitch.org](http://jira.freeswitch.org)进行错误报告（参见[向GitHub报告问题](../Troubleshooting-Debugging/Reporting-Issues-to-GitHub_5046304.mdx#about)）。

### 附件：

![](/images/icons/bullet_blue.gif) [Answering machine sound effect.mp3](/attachments/1049372/10682567.mp3) (audio/mp3)  
![](/images/icons/bullet_blue.gif) [answering\_machine\_sound\_effect\_8000.raw](/attachments/1049372/10682568.raw) (image/x-panasonic-raw)  
![](/images/icons/bullet_blue.gif) [avmd.png](/attachments/1049372/11829257.png) (image/png)  
![](/images/icons/bullet_blue.gif) [avmd\_example\_confluence.png](/attachments/1049372/10683543.png) (image/png)  
![](/images/icons/bullet_blue.gif) [avmd.activity.violet.html](/attachments/1049372/11829256.html) (text/html)  
![](/images/icons/bullet_blue.gif) [avmd.png](/attachments/1049372/11829265.png) (image/png)  
![](/images/icons/bullet_blue.gif) [avmd.png](/attachments/1049372/10683540.png) (image/png)  
![](/images/icons/bullet_blue.gif) [avmd\_get\_events.pl](/attachments/1049372/11829291.pl) (application/octet-stream)  

### 评论：

| 这是控制台输出: \------------------------------freeswitch@ip-172-30-13-241> uuid\_buglist 85f6990e-e3b3-463c-8765-ae645336259c &lt;media-bugs>&lt;/media-bugs> freeswitch@ip-172-30-13-241> avmd 85f6990e-e3b3-463c-8765-ae645336259c start+OK \[85f6990e-e3b3-463c-8765-ae645336259c\] \[sofia/internal/1234@192.168.175.140\] 已启动！  2017-07-12 01:17:02.428332 \[INFO\] mod\_avmd.c:372 Avmd 会话已初始化，\[8000\] 采样/秒2017-07-12 01:17:02.428332 \[DEBUG\] switch\_core\_media\_bug.c:828 将 BUG 附加到 sofia/internal/1234@192.168.175.1402017-07-12 01:17:02.428332 \[INFO\] mod\_avmd.c:1520 Avmd 在通道 \[sofia/internal/1234@192.168.175.140\] 上已启动！2017-07-12 01:17:02.468346 \[DEBUG\] switch\_core\_io.c:448 设置 BUG 编解码器 PCMU:0freeswitch@ip-172-30-13-241> uuid\_buglist 85f6990e-e3b3-463c-8765-ae645336259c&lt;media-bugs> &lt;media-bug>  &lt;function>avmd&lt;/function>  &lt;target>N/A&lt;/target>  &lt;thread-locked>0&lt;/thread-locked> &lt;/media-bug>&lt;/media-bugs> freeswitch@ip-172-30-13-241> avmd 85f6990e-e3b3-463c-8765-ae645336259c stop   +OK \[85f6990e-e3b3-463c-8765-ae645336259c\] \[sofia/internal/1234@192.168.175.140\] 已停止！  2017-07-12 01:17:14.668350 \[DEBUG\] switch\_core\_media\_bug.c:1198 从 sofia/internal/1234@192.168.175.140 上移除 BUG2017-07-12 01:17:14.668350 \[ERR\] mod\_avmd.c:495 错误，媒体 BUG 中找不到 avmd 会话对象！2017-07-12 01:17:14.668350 \[INFO\] mod\_avmd.c:1419 Avmd 在通道 \[sofia/internal/1234@192.168.175.140\] 上已停止！freeswitch@ip-172-30-13-241> uuid\_buglist 85f6990e-e3b3-463c-8765-ae645336259c&lt;media-bugs>&lt;/media-bugs>\------------------------------ 我要指出的问题是，即使媒体 BUG 已成功移除，一切似乎正常运作，但我们仍然看到一条错误日志。![](/images/icons/contenttypes/comment_16.png) 于 2017 年 7 月 11 日 21:19 由 tomasb 发布 |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 谢谢 Tom。这个问题已经修复，请升级到最新版本。![](/images/icons/contenttypes/comment_16.png) 于 2019 年 12 月 11 日 10:46 由 piotrgregor 发布 |

# 服务条款

## 欢迎来到我们的网站！

感谢您访问我们的网站。请阅读以下条款和条件，了解我们的服务使用规定。请注意，访问和使用我们的网站即表示您同意遵守这些条款和条件。如果您不同意这些条款和条件，请立即停止访问和使用本网站。

## 服务内容

1. 当您使用我们的网站时，请确保您已年满18岁或在您所在的国家或地区达到法定成年年龄。
2. 在我们的网站上，您将获得有关我们公司和产品的信息。我们会尽力确保这些信息的准确性和完整性，但并不对其准确性或完整性做出任何明示或暗示的保证。
3. 我们的网站上也可能提供其他公司或第三方的链接和信息。这些链接和信息仅供参考，我们无法控制或保证其内容的准确性、完整性和可靠性。因此，您使用这些链接和信息时需自行承担风险。

## 用户行为

1. 当您在我们的网站上发表评论或提供任何其他形式的内容时，请确保您遵守法律法规并尊重他人的权益。
2. 您不得提交任何虚假、诽谤、淫秽、威胁、歧视或其他违法或不道德的内容。
3. 您不得干扰或破坏我们的网站的正常运行，也不得采取任何可能对我们网站或其用户造成损害的行为。
4. 我们保留拒绝或删除任何违反上述规定的内容的权利，同时可能采取适当的法律行动。

## 免责声明

1. 在适用法律允许的最大范围内，我们对您使用我们的网站所产生的任何直接或间接损失或损害不承担任何责任。
2. 我们不对我们的网站的可用性做出任何明示或暗示的保证。我们保留随时暂停、限制或终止本网站使用的权利。
3. 我们不担保我们网站上的信息的准确性、完整性和可靠性。

## 知识产权

1. 我们的网站上的所有内容，包括但不限于文字、图片、标志和商标，均受版权和其他知识产权法律的保护。
2. 您不得未经我们的事先书面许可复制、修改、传播、展示或以其他方式使用本网站上的任何内容。

## 其他条款

1. 我们保留随时修改或更新这些条款和条件的权利，恕不另行通知。更新后的条款和条件将在我们的网站上公布。
2. 如果您继续访问和使用我们的网站，则视为您同意遵守更新后的条款和条件。

如果您对这些条款和条件有任何疑问，请联系我们。感谢您的合作！